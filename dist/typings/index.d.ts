// Generated by dts-bundle v0.7.3
// Dependencies for this module:
//   ../react
//   ../@ridi/reader.js/web

declare module '@ridi/react-reader' {
    import EpubReader from '@ridi/react-reader/components/EpubReader';
    import ComicReader from '@ridi/react-reader/components/ComicReader';
    import ReaderJsHelper from '@ridi/react-reader/ReaderJsHelper';
    export { EpubReader, ComicReader, ReaderJsHelper, };
    export * from '@ridi/react-reader/EpubService';
    export * from '@ridi/react-reader/ComicService';
    export * from '@ridi/react-reader/contexts';
    export * from '@ridi/react-reader/ReaderJsHelper';
    export * from '@ridi/react-reader/constants';
    export * from '@ridi/react-reader/utils';
}

declare module '@ridi/react-reader/components/EpubReader' {
    const EpubReader: () => JSX.Element;
    export default EpubReader;
}

declare module '@ridi/react-reader/components/ComicReader' {
    import * as React from 'react';
    import { ImageRenderers } from '@ridi/react-reader/components/Image/index';
    interface ComicReaderProps {
        renderers?: ImageRenderers;
    }
    const ComicReader: React.FunctionComponent<ComicReaderProps>;
    export default ComicReader;
}

declare module '@ridi/react-reader/ReaderJsHelper' {
    import { Content, Context, Reader, Rect, RectList } from '@ridi/reader.js/web';
    import { EpubCalculationState, EpubCurrentState, EpubSettingState, SpineCalculationState } from '@ridi/react-reader/contexts';
    class ReaderJsHelper {
            static init(context: Context, { currentState, calculationState, settingState }: {
                    currentState: EpubCurrentState;
                    calculationState: EpubCalculationState;
                    settingState: EpubSettingState;
            }): void;
            static updateContents(contentsRef: Array<HTMLElement>, contentWrapperRef: HTMLElement): void;
            static updateContext(context: Context): void;
            static updateState({ currentState, calculationState, settingState }: {
                    currentState: EpubCurrentState;
                    calculationState: EpubCalculationState;
                    settingState: EpubSettingState;
            }): void;
            static get(key?: number | string | HTMLElement): Content | null;
            static getReaderJs(): Reader | null;
            /**
                * 특정 포인트로부터 SpineCalculationState를 반환한다.
                * @param clientX
                * @param clientY
                */
            static getSpineIndexByPoint(clientX: number, clientY: number): SpineCalculationState | null;
            /**
                * 특정 포인트로부터 Reader.js content 인스턴스를 반환한다.
                * @param clientX
                * @param clientY
                */
            static getByPoint(clientX: number, clientY: number): Content | null;
            static reviseImages(): Promise<unknown[]> | undefined;
    }
    export default ReaderJsHelper;
    export { Context, Rect, RectList };
}

declare module '@ridi/react-reader/EpubService' {
    import { EpubCalculationAction, EpubCalculationState, EpubCurrentAction, EpubCurrentState, EpubSettingAction, EpubSettingState } from '@ridi/react-reader/contexts';
    import * as React from 'react';
    export interface FontData {
        href: string;
        uri?: string;
    }
    export interface EpubParsedData {
        type: 'epub';
        fonts?: Array<FontData>;
        styles?: Array<String>;
        spines?: Array<String>;
        unzipPath: string;
    }
    interface EpubServiceProperties {
        dispatchSetting: React.Dispatch<EpubSettingAction>;
        dispatchCalculation: React.Dispatch<EpubCalculationAction>;
        dispatchCurrent: React.Dispatch<EpubCurrentAction>;
        settingState: EpubSettingState;
        currentState: EpubCurrentState;
        calculationState: EpubCalculationState;
    }
    export class EpubService {
        static init(props: EpubServiceProperties): void;
        static destroy(): void;
        static isInitialized(): boolean;
        static get(): EpubService;
        static updateState({ settingState, currentState, calculationState, }: {
            settingState: EpubSettingState;
            currentState: EpubCurrentState;
            calculationState: EpubCalculationState;
        }): void;
        goToPage: (requestPage: number) => void;
        invalidate: () => void;
        load: (metadata: EpubParsedData) => void;
        updateCurrent: () => void;
        updateSetting: (setting: Partial<EpubSettingState>) => void;
    }
    export {};
}

declare module '@ridi/react-reader/ComicService' {
    import * as React from 'react';
    import { ComicCalculationAction, ComicCalculationState, ComicCurrentAction, ComicCurrentState, ComicSettingAction, ComicSettingState } from '@ridi/react-reader/contexts';
    export interface ImageData {
        size: number;
        index: number;
        path: string;
        uri?: string;
        width?: number;
        height?: number;
    }
    export interface ComicParsedData {
        type: 'comic';
        images?: Array<ImageData>;
        unzipPath: string;
    }
    interface ComicServiceProperties {
        dispatchSetting: React.Dispatch<ComicSettingAction>;
        dispatchCalculation: React.Dispatch<ComicCalculationAction>;
        dispatchCurrent: React.Dispatch<ComicCurrentAction>;
        settingState: ComicSettingState;
        currentState: ComicCurrentState;
        calculationState: ComicCalculationState;
    }
    export class ComicService {
        static init(props: ComicServiceProperties): void;
        static destroy(): void;
        static isInitialized(): boolean;
        static get(): ComicService;
        static updateState({ settingState, currentState, calculationState, }: {
            settingState: ComicSettingState;
            currentState: ComicCurrentState;
            calculationState: ComicCalculationState;
        }): void;
        invalidate: () => void;
        load: (metadata: ComicParsedData) => void;
        goToPage: (requestPage: number) => void;
        updateSetting: (setting: Partial<ComicSettingState>) => void;
        updateCurrent: () => void;
    }
    export {};
}

declare module '@ridi/react-reader/contexts' {
    export * from '@ridi/react-reader/contexts/epub/EpubSettingContext';
    export * from '@ridi/react-reader/contexts/epub/EpubCalculationContext';
    export * from '@ridi/react-reader/contexts/epub/EpubCurrentContext';
    export * from '@ridi/react-reader/contexts/epub/EpubProvider';
    export * from '@ridi/react-reader/contexts/comic/ComicSettingContext';
    export * from '@ridi/react-reader/contexts/comic/ComicCalculationContext';
    export * from '@ridi/react-reader/contexts/comic/ComicCurrentContext';
    export * from '@ridi/react-reader/contexts/comic/ComicProvider';
}

declare module '@ridi/react-reader/constants' {
    export enum ViewType {
        SCROLL = "scroll",
        PAGE1 = "page1",
        PAGE12 = "page12",
        PAGE23 = "page23"
    }
    export enum BindingType {
        LEFT = "left",
        RIGHT = "right"
    }
    export enum ImageStatus {
        NONE = "none",
        LOADING = "loading",
        ERROR = "error",
        LOADED = "loaded"
    }
}

declare module '@ridi/react-reader/utils' {
    import { Context, Rect, RectList } from '@ridi/reader.js/web';
    import * as ComicSettingUtil from '@ridi/react-reader/utils/ComicSettingUtil';
    import * as EpubSettingUtil from '@ridi/react-reader/utils/EpubSettingUtil';
    import * as Util from '@ridi/react-reader/utils/Util';
    export const SettingUtil: typeof EpubSettingUtil;
    export { EpubSettingUtil, ComicSettingUtil, Util, Context, Rect, RectList, };
}

declare module '@ridi/react-reader/components/Image/index' {
    import * as React from 'react';
    import { ImageData } from '@ridi/react-reader/ComicService';
    import { ComicSettingState } from '@ridi/react-reader/contexts';
    export type ErrorRendererType = React.FunctionComponent<{
        retry: () => void;
    }>;
    export type LoadingRendererType = React.FunctionComponent;
    export type ImageRendererType = React.FunctionComponent;
    export interface ImageRenderers {
        ErrorRenderer?: ErrorRendererType;
        LoadingRenderer?: LoadingRendererType;
        ImageRenderer?: ImageRendererType;
    }
    export interface ImageProps {
        image: ImageData;
        renderers?: ImageRenderers;
    }
    export const Image: React.FunctionComponent<ImageProps>;
    export const DefaultImageLoading: LoadingRendererType;
    export const DefaultImageError: ErrorRendererType;
    export const BlankImage: React.FunctionComponent<{
        settingState: ComicSettingState;
    }>;
}

declare module '@ridi/react-reader/contexts/epub/EpubSettingContext' {
    import { Reducer } from 'react';
    import { ViewType } from '@ridi/react-reader/constants';
    export enum EpubSettingActionType {
        UPDATE_SETTING = "update_setting"
    }
    export enum EpubSettingProperties {
        VIEW_TYPE = "viewType",
        FONT = "font",
        FONT_SIZE_IN_EM = "fontSizeInEm",
        LINE_HEIGHT_IN_EM = "lineHeightInEm",
        CONTENT_PADDING_IN_PERCENT = "contentPaddingInPercent",
        COLUMN_GAP_IN_PERCENT = "columnGapInPercent",
        PARAGRAPH_SPACING_IN_EM = "paragraphSpacingInEm",
        CONTAINER_HORIZONTAL_MARGIN = "containerHorizontalMargin",
        CONTAINER_VERTICAL_MARGIN = "containerVerticalMargin",
        AUTO_INVALIDATION = "autoInvalidation"
    }
    export type EpubSettingAction = {
        type: EpubSettingActionType.UPDATE_SETTING;
        setting: Partial<EpubSettingState>;
    };
    export type EpubSettingState = {
        [EpubSettingProperties.VIEW_TYPE]: ViewType;
        [EpubSettingProperties.FONT]: string;
        [EpubSettingProperties.FONT_SIZE_IN_EM]: number;
        [EpubSettingProperties.LINE_HEIGHT_IN_EM]: number;
        [EpubSettingProperties.CONTENT_PADDING_IN_PERCENT]: number;
        [EpubSettingProperties.COLUMN_GAP_IN_PERCENT]: number;
        [EpubSettingProperties.PARAGRAPH_SPACING_IN_EM]: number;
        [EpubSettingProperties.CONTAINER_HORIZONTAL_MARGIN]: number;
        [EpubSettingProperties.CONTAINER_VERTICAL_MARGIN]: number;
        [EpubSettingProperties.AUTO_INVALIDATION]: boolean;
    };
    export const initialEpubSettingState: EpubSettingState;
    export const EpubSettingReducer: Reducer<EpubSettingState, EpubSettingAction>;
    export const EpubSettingDispatchContext: import("react").Context<import("react").Dispatch<EpubSettingAction>>, EpubSettingContext: import("react").Context<EpubSettingState>, EpubSettingContextProvider: import("react").FunctionComponent<{
        children: import("react").ReactNode;
        customInitialState?: Partial<EpubSettingState> | undefined;
    }>;
}

declare module '@ridi/react-reader/contexts/epub/EpubCalculationContext' {
    import * as React from 'react';
    export enum EpubCalculationActionType {
        UPDATE_CALCULATION = "update_calculation"
    }
    export enum EpubCalculationProperties {
        TOTAL_PAGE = "totalPage",
        TOTAL = "total",
        PAGE_UNIT = "pageUnit",
        SPINES = "spines"
    }
    export type EpubCalculationAction = {
        type: EpubCalculationActionType.UPDATE_CALCULATION;
        calculation: Partial<EpubCalculationState>;
    };
    export type SpineCalculationState = {
        spineIndex: number;
        offset: number;
        total: number;
        startPage: number;
        totalPage: number;
    };
    export type EpubCalculationState = {
        [EpubCalculationProperties.TOTAL_PAGE]: number;
        [EpubCalculationProperties.TOTAL]: number;
        [EpubCalculationProperties.PAGE_UNIT]: number;
        [EpubCalculationProperties.SPINES]: Array<SpineCalculationState>;
    };
    export const initialEpubCalculationState: EpubCalculationState;
    export const EpubCalculationReducer: React.Reducer<EpubCalculationState, EpubCalculationAction>;
    export const EpubCalculationDispatchContext: React.Context<React.Dispatch<EpubCalculationAction>>, EpubCalculationContext: React.Context<EpubCalculationState>, EpubCalculationContextProvider: React.FunctionComponent<{
        children: React.ReactNode;
        customInitialState?: Partial<EpubCalculationState> | undefined;
    }>;
}

declare module '@ridi/react-reader/contexts/epub/EpubCurrentContext' {
    import * as React from 'react';
    export enum EpubCurrentActionType {
        UPDATE_CURRENT = "update_current",
        SET_READY_TO_READ = "set_ready_to_read"
    }
    export enum EpubCurrentProperties {
        CURRENT_PAGE = "currentPage",
        CURRENT_SPINE_INDEX = "currentSpineIndex",
        CURRENT_POSITION = "currentPosition",
        READY_TO_READ = "readyToRead",
        VISIBLE_SPINE_INDEXES = "visibleSpineIndexes"
    }
    export type EpubCurrentAction = {
        type: EpubCurrentActionType.UPDATE_CURRENT;
        current: Partial<EpubCurrentState>;
    } | {
        type: EpubCurrentActionType.SET_READY_TO_READ;
        readyToRead: boolean;
    };
    export type EpubCurrentState = {
        [EpubCurrentProperties.CURRENT_PAGE]: number;
        [EpubCurrentProperties.CURRENT_SPINE_INDEX]: number;
        [EpubCurrentProperties.CURRENT_POSITION]: number;
        [EpubCurrentProperties.READY_TO_READ]: boolean;
        [EpubCurrentProperties.VISIBLE_SPINE_INDEXES]: number[];
    };
    export const initialEpubCurrentState: EpubCurrentState;
    export const EpubCurrentReducer: React.Reducer<EpubCurrentState, EpubCurrentAction>;
    export const EpubCurrentDispatchContext: React.Context<React.Dispatch<EpubCurrentAction>>, EpubCurrentContext: React.Context<EpubCurrentState>, EpubCurrentContextProvider: React.FunctionComponent<{
        children: React.ReactNode;
        customInitialState?: Partial<EpubCurrentState> | undefined;
    }>;
}

declare module '@ridi/react-reader/contexts/epub/EpubProvider' {
    import { EpubCalculationState } from '@ridi/react-reader/contexts/epub/EpubCalculationContext';
    import { EpubSettingState } from '@ridi/react-reader/contexts/epub/EpubSettingContext';
    import { EpubCurrentState } from '@ridi/react-reader/contexts/epub/EpubCurrentContext';
    import * as React from 'react';
    export interface EpubProviderProps {
        children: React.ReactNode;
        settingState?: Partial<EpubSettingState>;
        calculationState?: Partial<EpubCalculationState>;
        currentState?: Partial<EpubCurrentState>;
    }
    export const EpubProvider: React.FunctionComponent<EpubProviderProps>;
}

declare module '@ridi/react-reader/contexts/comic/ComicSettingContext' {
    import { Reducer } from "react";
    import { ViewType, BindingType } from '@ridi/react-reader/constants';
    export enum ComicSettingActionType {
        UPDATE_SETTING = "update_setting"
    }
    export enum ComicSettingProperties {
        VIEW_TYPE = "viewType",
        CONTENT_WIDTH_IN_PERCENT = "contentWidthInPercent",
        BINDING_TYPE = "bindingType",
        LAZY_LOAD = "lazyLoad"
    }
    export type ComicSettingAction = {
        type: ComicSettingActionType.UPDATE_SETTING;
        setting: Partial<ComicSettingState>;
    };
    export type ComicSettingState = {
        [ComicSettingProperties.VIEW_TYPE]: ViewType;
        [ComicSettingProperties.CONTENT_WIDTH_IN_PERCENT]: number;
        [ComicSettingProperties.BINDING_TYPE]: BindingType;
        [ComicSettingProperties.LAZY_LOAD]: boolean | number;
    };
    export const initialComicSettingState: ComicSettingState;
    export const ComicSettingReducer: Reducer<ComicSettingState, ComicSettingAction>;
    export const ComicSettingDispatchContext: import("react").Context<import("react").Dispatch<ComicSettingAction>>, ComicSettingContext: import("react").Context<ComicSettingState>, ComicSettingContextProvider: import("react").FunctionComponent<{
        children: import("react").ReactNode;
        customInitialState?: Partial<ComicSettingState> | undefined;
    }>;
}

declare module '@ridi/react-reader/contexts/comic/ComicCalculationContext' {
    import * as React from 'react';
    export enum ComicCalculationActionType {
            UPDATE_CALCULATION = "update_calculation"
    }
    export enum ComicCalculationProperties {
            TOTAL_PAGE = "totalPage",
            PAGE_UNIT = "pageUnit",
            IMAGES = "images"
    }
    export type ComicCalculationAction = {
            type: ComicCalculationActionType.UPDATE_CALCULATION;
            calculation: Partial<ComicCalculationState>;
    };
    export type ImageCalculationState = {
            imageIndex: number;
            /**
                * height / width
                * immutable value
                */
            ratio: number;
            /**
                *  start offset in px on scroll view mode
                *  modified when resizing or changing setting.contentWidth
                */
            offsetTop: number;
            height: number;
    };
    export type ComicCalculationState = {
            [ComicCalculationProperties.TOTAL_PAGE]: number;
            [ComicCalculationProperties.PAGE_UNIT]: number;
            [ComicCalculationProperties.IMAGES]: Array<ImageCalculationState>;
    };
    export const initialComicCalculationState: ComicCalculationState;
    export const ComicCalculationReducer: React.Reducer<ComicCalculationState, ComicCalculationAction>;
    export const ComicCalculationDispatchContext: React.Context<React.Dispatch<ComicCalculationAction>>, ComicCalculationContext: React.Context<ComicCalculationState>, ComicCalculationContextProvider: React.FunctionComponent<{
            children: React.ReactNode;
            customInitialState?: Partial<ComicCalculationState> | undefined;
    }>;
}

declare module '@ridi/react-reader/contexts/comic/ComicCurrentContext' {
    import * as React from 'react';
    export enum ComicCurrentActionType {
        UPDATE_CURRENT = "update_current",
        SET_READY_TO_READ = "set_ready_to_read"
    }
    export enum ComicCurrentProperties {
        CURRENT_PAGE = "currentPage",
        READY_TO_READ = "readyToRead"
    }
    export type ComicCurrentAction = {
        type: ComicCurrentActionType.UPDATE_CURRENT;
        current: Partial<ComicCurrentState>;
    } | {
        type: ComicCurrentActionType.SET_READY_TO_READ;
        readyToRead: boolean;
    };
    export type ComicCurrentState = {
        [ComicCurrentProperties.CURRENT_PAGE]: number;
        [ComicCurrentProperties.READY_TO_READ]: boolean;
    };
    export const initialComicCurrentState: ComicCurrentState;
    export const ComicCurrentReducer: React.Reducer<ComicCurrentState, ComicCurrentAction>;
    export const ComicCurrentDispatchContext: React.Context<React.Dispatch<ComicCurrentAction>>, ComicCurrentContext: React.Context<ComicCurrentState>, ComicCurrentContextProvider: React.FunctionComponent<{
        children: React.ReactNode;
        customInitialState?: Partial<ComicCurrentState> | undefined;
    }>;
}

declare module '@ridi/react-reader/contexts/comic/ComicProvider' {
    import { ComicCalculationState } from '@ridi/react-reader/contexts/comic/ComicCalculationContext';
    import { ComicSettingState } from '@ridi/react-reader/contexts/comic/ComicSettingContext';
    import { ComicCurrentState } from '@ridi/react-reader/contexts/comic/ComicCurrentContext';
    import * as React from 'react';
    export interface ComicProviderProps {
        children: React.ReactNode;
        settingState?: Partial<ComicSettingState>;
        calculationState?: Partial<ComicCalculationState>;
        currentState?: Partial<ComicCurrentState>;
    }
    export const ComicProvider: React.FunctionComponent<ComicProviderProps>;
}

declare module '@ridi/react-reader/utils/ComicSettingUtil' {
    import { ComicCalculationState, ComicSettingState } from '@ridi/react-reader/contexts';
    export const isScroll: ({ viewType }: ComicSettingState) => boolean;
    export const isDoublePage: ({ viewType }: ComicSettingState) => boolean;
    export const columnsInPage: ({ viewType }: ComicSettingState) => number;
    export const contentWidth: (setting: ComicSettingState) => number;
    export const ratio: (width?: number | undefined, height?: number | undefined) => number;
    export const containerWidth: (setting: ComicSettingState, calculation: ComicCalculationState) => number;
    export const allowedPageNumber: (setting: ComicSettingState, calculation: ComicCalculationState, page: number) => number;
    export const objectPosition: (setting: ComicSettingState, imageIndex: number) => "50% 50%" | "right 50%" | "left 50%";
    export const startWithBlankPage: ({ viewType }: ComicSettingState) => boolean;
}

declare module '@ridi/react-reader/utils/EpubSettingUtil' {
    import { EpubCalculationState, EpubSettingState } from '@ridi/react-reader/contexts';
    export const isScroll: ({ viewType }: EpubSettingState) => boolean;
    export const isDoublePage: ({ viewType }: EpubSettingState) => boolean;
    export const columnsInPage: ({ viewType }: EpubSettingState) => number;
    export const columnWidth: (setting: EpubSettingState) => number;
    export const columnGap: ({ columnGapInPercent }: EpubSettingState) => number;
    export const contentPadding: ({ contentPaddingInPercent }: EpubSettingState) => number;
    export const containerWidth: (setting: EpubSettingState) => number;
    export const containerHeight: ({ containerVerticalMargin }: EpubSettingState) => number;
    export const allowedPageNumber: (setting: EpubSettingState, calculation: EpubCalculationState, page: number) => number;
}

declare module '@ridi/react-reader/utils/Util' {
    export const getRootElement: () => Element | null;
    export const getContentRootElement: () => HTMLElement | null;
    export const getContentContainerElement: () => HTMLElement | null;
    export const getScrollWidth: () => number;
    export const getScrollHeight: () => number;
    export const getScrollLeft: () => number;
    export const getScrollTop: () => number;
    export const setScrollLeft: (scrollLeft: number) => void;
    export const setScrollTop: (scrollTop: number) => void;
    export const getClientWidth: () => number;
    export const getClientHeight: () => number;
    /**
        * Create a debounced(grouping multiple event listener in one) function
        * And the latest invoking of this deboucnced function will only be taken after `wait` miliseconds periods.
        *
        * @param {function} fn
        * @param {number} [wait=100]
        * @param {boolean} [immediate=false]
        * @return {function} debounced function
        */
    export const debounce: (fn: () => any, wait?: number, immediate?: boolean) => () => void;
    /**
        * Create a throttled(invoking only once in specified limited time) function
        *
        * @param {function} fn
        * @param {number} [limit=100] up to 1 invoke per ${limit} milliseconds
        * @param {boolean} [delayed=false] invoke ${fn} after ${limit} milliseconds delayed
        * @returns {function} throttled function
        */
    export const throttle: (fn: () => any, limit?: number, delayed?: boolean) => () => void;
    export const sleep: (millisecond?: number) => Promise<void>;
    export const hasIntersect: (r1: number[], r2: number[]) => boolean;
    export const logger: {
            (message?: any, ...optionalParams: any[]): void;
            (message?: any, ...optionalParams: any[]): void;
    };
}

